import { StreamChat } from "stream-chat";

// Stream Chat API Key (public - safe to expose in frontend)
const STREAM_API_KEY = import.meta.env.VITE_STREAM_API_KEY;

// Backend URL for API calls
const BACKEND_URL = `${import.meta.env.VITE_BACKEND_URL}/api`;

// Singleton client instance
let clientInstance = null;

/**
 * Get or create the Stream Chat client instance
 * @returns {StreamChat} The Stream Chat client
 */
export const getStreamClient = () => {
  console.log("STREAM_API_KEY:", STREAM_API_KEY); // Debug log to verify API key presence
  if (!clientInstance && STREAM_API_KEY) {
    clientInstance = StreamChat.getInstance(STREAM_API_KEY);
  }
  return clientInstance;
};

/**
<<<<<<< HEAD
 * Normalize ISBN by removing dashes and spaces
 * @param {string} isbn - The ISBN to normalize
 * @returns {string} Normalized ISBN
 */
export const normalizeIsbn = (isbn) => {
  return (isbn || "").replace(/-/g, "").replace(/\s/g, "").toUpperCase();
};

/**
 * Generate a consistent channel ID from a book ISBN
 * This ensures all users discussing the same book (by ISBN) join the same channel
 * @param {string} isbn - The book's ISBN
 * @returns {string} The channel ID
 */
export const generateBookChannelIdByIsbn = (isbn) => {
  const normalized = normalizeIsbn(isbn);
  if (!normalized) return null;
  return `book-isbn-${normalized}`;
};

/**
 * Generate a consistent channel ID from a book title (legacy, kept for compatibility)
 * This ensures all users discussing the same book join the same channel
 * @param {string} bookTitle - The title of the book
 * @returns {string} The channel ID
 * @deprecated Use generateBookChannelIdByIsbn instead for better matching

 */
export const generateBookChannelId = (bookTitle) => {
  return `book-${bookTitle
    .toLowerCase()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "") // Remove accents
    .replace(/[^a-z0-9\s-]/g, "") // Remove special characters
    .replace(/\s+/g, "-") // Replace spaces with hyphens
    .replace(/-+/g, "-") // Replace multiple hyphens with single
    .trim()}`;
};

/**
 * Connect a user to Stream Chat
 * @param {string} userId - The user's ID from your backend
 * @param {string} userName - The user's display name
 * @param {string} streamToken - The Stream token generated by your backend
 * @param {string} userImage - Optional user avatar URL
 * @returns {Promise<Object>} The connected user object
 */
export const connectUser = async (
  userId,
  userName,
  streamToken,
  userImage = null,
) => {
  const client = getStreamClient();

  if (!client) {
    throw new Error(
      "Stream Chat client not initialized. Check VITE_STREAM_API_KEY.",
    );
  }

  // Disconnect any existing user first
  if (client.userID) {
    await client.disconnectUser();
  }

  const userConfig = {
    id: userId,
    name: userName,
  };

  if (userImage) {
    userConfig.image = userImage;
  }

  return await client.connectUser(userConfig, streamToken);
};

/**
 * Disconnect the current user from Stream Chat
 */
export const disconnectUser = async () => {
  const client = getStreamClient();
  if (client && client.userID) {
    await client.disconnectUser();
  }
};

/**
<<<<<<< HEAD
 * Create or join a channel for a book discussion using ISBN
 * Uses the backend API to create/join channels (server has proper permissions)
 * @param {Object} book - The book object with isbn, title, thumbnail, authors
 * @returns {Promise<Object>} The channel object
 */
export const createOrJoinBookChannelByIsbn = async (book) => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before creating a channel");
  }

  const accessToken = localStorage.getItem("access_token");
  if (!accessToken) {
    throw new Error("No access token found");
  }

  const isbn = normalizeIsbn(book?.isbn);
  if (!isbn) {
    throw new Error("Book must have a valid ISBN to create a chat");
  }

  // Use backend API to create/join channel by ISBN
  const response = await fetch(`${BACKEND_URL}/chat/create-or-join-channel-by-isbn`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${accessToken}`,
    },
    body: JSON.stringify({
      isbn: isbn,
      book_title: book.title || "Libro sin tÃ­tulo",
      thumbnail: book.thumbnail || null,
      authors: book.authors || [],
    }),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || "Error creating/joining channel");
  }

  const data = await response.json();
  const channelId = data.channel_id;

  // Now watch the channel from the client
  const channel = client.channel("messaging", channelId);
  await channel.watch();

  return channel;
};

/**
 * Create or join a channel for a book discussion (legacy - by title)
 * Uses the backend API to create/join channels (server has proper permissions)
 * @param {string} bookTitle - The book being discussed
 * @returns {Promise<Object>} The channel object
 * @deprecated Use createOrJoinBookChannelByIsbn instead
=======
 * Create or join a channel for a book discussion
 * Uses the backend API to create/join channels (server has proper permissions)
 * @param {string} bookTitle - The book being discussed
 * @returns {Promise<Object>} The channel object
>>>>>>> origin/german_branch
 */
export const createOrJoinBookChannel = async (bookTitle) => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before creating a channel");
  }

  const accessToken = localStorage.getItem("access_token");
  if (!accessToken) {
    throw new Error("No access token found");
  }

  // Use backend API to create/join channel (server has proper permissions)
  const response = await fetch(`${BACKEND_URL}/chat/create-or-join-channel`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${accessToken}`,
    },
    body: JSON.stringify({ book_title: bookTitle }),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || "Error creating/joining channel");
  }

  const data = await response.json();
  const channelId = data.channel_id;

  // Now watch the channel from the client
  const channel = client.channel("messaging", channelId);
  await channel.watch();

  return channel;
};

/**
 * Legacy function for backward compatibility
 * @deprecated Use createOrJoinBookChannel instead
 */
export const createBookChannel = async (
  channelId,
  bookTitle,
  memberIds = [],
) => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before creating a channel");
  }

  const channel = client.channel("messaging", channelId, {
    name: `ðŸ“š ${bookTitle}`,
    book_title: bookTitle,
    members: memberIds,
  });

  await channel.watch();
  return channel;
};

/**
 * Get an existing channel by ID
 * @param {string} channelId - The channel ID
 * @returns {Promise<Object>} The channel object
 */
export const getChannel = async (channelId) => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before accessing a channel");
  }

  const channel = client.channel("messaging", channelId);
  await channel.watch();
  return channel;
};

/**
 * Get all channels the current user is a member of
 * @returns {Promise<Array>} Array of channel objects
 */
export const getUserChannels = async () => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before fetching channels");
  }

  const filter = {
    type: "messaging",
    members: { $in: [client.userID] },
  };
  const sort = [{ last_message_at: -1 }];

  const channels = await client.queryChannels(filter, sort, {
    watch: true,
    state: true,
  });

  return channels;
};

/**
 * Get all public book discussion channels (not just user's channels)
 * Uses the backend API to fetch channels (server has proper permissions)
 * @returns {Promise<Array>} Array of channel data objects
 */
export const getAllBookChannels = async () => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before fetching channels");
  }

  const accessToken = localStorage.getItem("access_token");
  if (!accessToken) {
    throw new Error("No access token found");
  }

  // Use backend API to get public channels
  const response = await fetch(`${BACKEND_URL}/chat/public-channels`, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || "Error fetching channels");
  }

  const data = await response.json();

  // Convert backend response to channel-like objects for compatibility
  // The backend returns simplified channel data, we need to format it
  return data.channels.map((ch) => ({
    id: ch.id,
    data: {
      name: ch.name,
      book_title: ch.book_title,
      member_count: ch.member_count,
    },
    state: {
      members: {}, // We don't have full member data from backend
    },
  }));
};

/**
 * Join an existing book channel
 * Uses the backend API to join channels (server has proper permissions)
 * @param {string} channelId - The channel ID to join
 * @returns {Promise<Object>} The channel object
 */
export const joinBookChannel = async (channelId) => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before joining a channel");
  }

  const accessToken = localStorage.getItem("access_token");
  if (!accessToken) {
    throw new Error("No access token found");
  }

  // Use backend API to join channel (server has proper permissions)
  const response = await fetch(
    `${BACKEND_URL}/chat/join-channel/${channelId}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`,
      },
    },
  );

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.message || "Error joining channel");
  }

  // Now watch the channel from the client
  const channel = client.channel("messaging", channelId);
  await channel.watch();

  return channel;
};

/**
 * Check if current user is a member of a channel
 * @param {Object} channel - The channel object (can be full channel or simplified from backend)
 * @returns {boolean}
 */
export const isUserMemberOfChannel = (channel) => {
  const client = getStreamClient();
  if (!client || !client.userID || !channel) return false;

  // For full channel objects from Stream
  if (channel.state?.members) {
    const members = channel.state.members;
    return Object.keys(members).includes(client.userID);
  }

  // For simplified channel data from backend, we can't know for sure
  // Return false to show "Unirse" button (joining again is harmless)
  return false;
};

/**
 * Check if the user is currently connected to Stream
 * @returns {boolean}
 */
export const isUserConnected = () => {
  const client = getStreamClient();
  return client && client.userID !== undefined;
};

/**
 * Get the current connected user ID
 * @returns {string|null}
 */
export const getCurrentUserId = () => {
  const client = getStreamClient();
  return client?.userID || null;
};

/**
 * Get the number of members in a channel
 * @param {Object} channel - The channel object (can be full channel or simplified from backend)
 * @returns {number}
 */
export const getChannelMemberCount = (channel) => {
  if (!channel) return 0;

  // For simplified channel data from backend
  if (channel.data?.member_count !== undefined) {
    return channel.data.member_count;
  }

  // For full channel objects from Stream
  if (channel.state?.members) {
    return Object.keys(channel.state.members).length;
  }

  return 0;
};

/**
 * Leave a channel (remove current user from members)
 * @param {string} channelId - The channel ID to leave
 * @returns {Promise<void>}
 */
export const leaveChannel = async (channelId) => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before leaving a channel");
  }

  const channel = client.channel("messaging", channelId);
  await channel.removeMembers([client.userID]);
};

/**
 * Delete a channel (only creator can do this)
 * @param {string} channelId - The channel ID to delete
 * @returns {Promise<void>}
 */
export const deleteChannel = async (channelId) => {
  const client = getStreamClient();

  if (!client || !client.userID) {
    throw new Error("User must be connected before deleting a channel");
  }

  const channel = client.channel("messaging", channelId);
  await channel.delete();
};

/**
 * Check if current user is the creator of a channel
 * @param {Object} channel - The channel object
 * @returns {boolean}
 */
export const isChannelCreator = (channel) => {
  const client = getStreamClient();
  if (!client || !client.userID || !channel) return false;

  const createdById =
    channel.data?.created_by_id || channel.data?.created_by?.id;
  return createdById === client.userID;
};

/**
 * Get channel creator info
 * @param {Object} channel - The channel object
 * @returns {Object|null}
 */
export const getChannelCreator = (channel) => {
  if (!channel || !channel.data) return null;
  return channel.data.created_by || null;
};

export { clientInstance as client };
